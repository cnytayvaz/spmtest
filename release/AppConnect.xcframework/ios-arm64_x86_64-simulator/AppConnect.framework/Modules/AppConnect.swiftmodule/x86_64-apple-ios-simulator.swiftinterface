// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name AppConnect
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AdSupport
@_exported import AppConnect
import AppTrackingTransparency
import CommonCrypto
import Compression
import CoreData
import CoreLocation
import CoreTelephony
import CryptoKit
import Darwin
import Dispatch
import Foundation
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import UserNotifications
import WebKit
import _Concurrency
import _StringProcessing
@_inheritsConvenienceInitializers @objc(APCAPMMutableHttpRecord) @objcMembers final public class APMMutableHttpRecord : ObjectiveC.NSObject {
  final public var success: Swift.Bool?
  @objc final public var errorType: Swift.String?
  @objc final public var errorCode: Swift.String?
  @objc final public var errorMessage: Swift.String?
  @objc final public var attributes: AppConnect.APMAttributes?
  @objc final public func setSuccess(_ isSuccess: Swift.Bool)
  @objc override dynamic public init()
  @objc deinit
}
public enum Platform : Swift.String, Swift.Codable {
  case iOS
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc(APCInboxMessageType) public enum InboxMessageType : Swift.Int {
  case push
  case inApp
  case geofence
  case actionBased
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc(APCInboxMessageStatus) public enum InboxMessageStatus : Swift.Int {
  case unread
  case read
  case dismissed
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc(APCInboxMessage) @objcMembers public class InboxMessage : ObjectiveC.NSObject {
  @objc public class var invalidMessageId: Swift.Int64 {
    @objc get
  }
  @objc final public let id: Swift.Int64
  @objc final public let type: AppConnect.InboxMessageType
  @objc final public let receivedDate: Foundation.Date?
  @objc final public let expirationDate: Foundation.Date?
  @objc final public let customerId: Swift.String?
  @objc final public let status: AppConnect.InboxMessageStatus
  @objc final public let pushEvent: AppConnect.PushEvent?
  final public let inAppMessage: AppConnect.InAppMessage?
  final public let actionBasedMessage: AppConnect.ActionBasedMessage?
  @objc public var payload: Swift.String? {
    @objc get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class FTS5Config : AppConnect.FTSConfig {
  @objc deinit
}
@objc public protocol AppConnectScreenTrackingConfigurator : ObjectiveC.NSObjectProtocol {
  @objc var apc_screenTrackingName: Swift.String { get }
}
@objc public protocol AppConnectScreenTrackingExclusion : ObjectiveC.NSObjectProtocol {
  @objc var apc_isAutoScreenTrackingExclusion: Swift.Bool { get }
}
@objc(APCInAppMessageLocation) public enum InAppMessageLocation : Swift.Int, Swift.CustomStringConvertible, Swift.Decodable {
  case top
  case bottom
  case fullScreen
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class AutoCollectingComponentConfig : ObjectiveC.NSObject {
  @objc final public var isEnabled: Swift.Bool
  @objc final public var debounceThreshold: Swift.Int
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(APCUserAttributes) @objcMembers public class UserAttributes : ObjectiveC.NSObject, Swift.Codable {
  @objc public var collections: [Swift.String : Any] {
    get
  }
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
extension AppConnect.UserAttributes {
  @objc @discardableResult
  dynamic public func addInt(_ value: Swift.Int, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addDouble(_ value: Swift.Double, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addFloat(_ value: Swift.Float, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addBool(_ value: Swift.Bool, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addString(_ value: Swift.String, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addDate(_ value: Foundation.Date, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addDecimal(_ value: Foundation.Decimal, forKey name: Swift.String) -> Self
}
@objc(APCSwitchButtonTrackingAttributes) @objcMembers final public class SwitchButtonTrackingAttributes : AppConnect.UIEventTrackingAttributes {
  @objc public init(switchButton: UIKit.UISwitch)
  @objc public init(className: Swift.String, isChecked: Swift.Bool, accessibilityLabel: Swift.String? = nil, componentId: Swift.String? = nil, coordinates: AppConnect.UIViewPixelCoordinate? = nil, viewLabel: Swift.String? = nil, viewClass: Swift.String? = nil)
  override final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@objc public protocol AppConnectEventListenerDelegate {
  @objc func firedEvent(attributes: [Swift.String : Any]?)
}
public struct InAppMessageSchedule : Swift.Codable {
  public var endDate: Foundation.Date? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_inheritsConvenienceInitializers @objc(APCViewTrackingExtras) @objcMembers final public class ViewTrackingExtras : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension AppConnect.ViewTrackingExtras {
  @objc @discardableResult
  final public func addInt(_ value: Swift.Int, forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addDouble(_ value: Swift.Double, forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addFloat(_ value: Swift.Float, forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addBool(_ value: Swift.Bool, forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addString(_ value: Swift.String, forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addDate(_ value: Foundation.Date, forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addDecimal(_ value: Foundation.Decimal, forKey name: Swift.String) -> Self
}
extension AppConnect.ViewTrackingExtras {
  @objc @discardableResult
  final public func addStringArray(_ value: [Swift.String], forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addIntArray(_ value: [Swift.Int], forKey name: Swift.String) -> Self
}
@_hasMissingDesignatedInitializers @objc(APCLoggerConfig) @objcMembers final public class LoggerConfig : ObjectiveC.NSObject {
  @objc final public var logLevel: AppConnect.LoggerLevel {
    @objc get
    @objc set
  }
  @objc final public var writeToFile: Swift.Bool {
    @objc get
    @objc set
  }
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers final public class AppConnectReservedEvent : ObjectiveC.NSObject {
  @objc public static let viewTrackingStart: Swift.String
  @objc public static let viewTrackingStop: Swift.String
  @objc public static let pushTokenUpdate: Swift.String
  @objc public static let languageUpdate: Swift.String
  @objc public static let userUpdate: Swift.String
  @objc public static let sessionStart: Swift.String
  @objc public static let sessionStop: Swift.String
  @objc public static let notificationOpen: Swift.String
  @objc public static let notificationReceive: Swift.String
  @objc public static let goalAchieved: Swift.String
  @objc public static let inAppMessageButtonClick: Swift.String
  @objc public static let inAppMessageRead: Swift.String
  @objc public static let inAppMessageClose: Swift.String
  @objc public static let inAppMessageFetched: Swift.String
  @objc public static let sdkFirstOpen: Swift.String
  @objc public static let deviceUpdateSettings: Swift.String
  @objc public static let apmNetworkError: Swift.String
  @objc public static let apmHTTPCall: Swift.String
  @objc public static let addToCart: Swift.String
  @objc public static let purchase: Swift.String
  @objc public static let search: Swift.String
  @objc public static let viewProduct: Swift.String
  @objc public static let viewCategory: Swift.String
  @objc public static let removeFromCart: Swift.String
  @objc public static let clearCart: Swift.String
  @objc public static let startCheckout: Swift.String
  @objc public static let errorCheckout: Swift.String
  @objc public static let addToWishList: Swift.String
  @objc public static let removeFromWishList: Swift.String
  @objc public static let deeplinkLaunched: Swift.String
  @objc public static let buttonClick: Swift.String
  @objc public static let toggleChange: Swift.String
  @objc public static let textChange: Swift.String
  @objc public static let touch: Swift.String
  @objc public static let swipe: Swift.String
  @objc public static let longPress: Swift.String
  @objc public static let doubleTap: Swift.String
  @objc public static let reservedEvents: Swift.Set<Swift.String>
  @objc deinit
}
extension UIKit.UIWindow {
  @_Concurrency.MainActor(unsafe) public func apc_gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
public protocol URLStringConvertible {
  var urlString: Swift.String { get }
}
extension Foundation.URLRequest : AppConnect.URLStringConvertible {
  public var urlString: Swift.String {
    get
  }
}
extension Foundation.URL : AppConnect.URLStringConvertible {
  public var urlString: Swift.String {
    get
  }
}
extension Foundation.URLComponents : AppConnect.URLStringConvertible {
  public var urlString: Swift.String {
    get
  }
}
extension Swift.String : AppConnect.URLStringConvertible {
  public var urlString: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers final public class LocationFetcher : ObjectiveC.NSObject {
  public enum Failure : Swift.Error {
    case cancelled
    case noLocations
    case locationManagerFailed(Swift.Error)
  }
  public typealias LocationCompletion = (AppConnect.Result<CoreLocation.CLLocation>) -> Swift.Void
  @objc override dynamic public init()
  final public func fetch(_ completion: @escaping AppConnect.LocationFetcher.LocationCompletion)
  final public func cancel()
  @objc deinit
}
extension AppConnect.LocationFetcher : CoreLocation.CLLocationManagerDelegate {
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, didUpdateLocations locations: [CoreLocation.CLLocation])
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, didFailWithError error: Swift.Error)
}
@_hasMissingDesignatedInitializers @objc(APCRemoveFromCartEventAttributes) @objcMembers final public class RemoveFromCartEventAttributes : AppConnect.Attributes {
  @objc convenience public init(product: AppConnect.Product, domain: Swift.String? = nil)
  @objc @discardableResult
  final public func addValue(_ value: Foundation.Decimal) -> AppConnect.RemoveFromCartEventAttributes
  @objc @discardableResult
  final public func addTotalCartValue(_ totalCartValue: Foundation.Decimal) -> AppConnect.RemoveFromCartEventAttributes
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class AppConnectAPMConfig : ObjectiveC.NSObject {
  @objc final public var recordCollectionEnabled: Swift.Bool
  @objc final public var recordStorageLimit: Swift.Int
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(APCAddToCardEventAttributes) @objcMembers final public class AddToCardEventAttributes : AppConnect.Attributes {
  @objc convenience public init(product: AppConnect.Product, domain: Swift.String? = nil)
  @objc @discardableResult
  final public func addValue(_ value: Foundation.Decimal) -> AppConnect.AddToCardEventAttributes
  @objc @discardableResult
  final public func addTotalCartValue(_ value: Foundation.Decimal) -> AppConnect.AddToCardEventAttributes
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(APCAppConnectDatabaseConfig) @objcMembers final public class AppConnectDatabaseConfig : ObjectiveC.NSObject {
  @objc public init(databaseEncryptionKey: [Swift.UInt8]?, databaseEncryptionEnabled: Swift.Bool)
  @objc final public func migrateToRawKey(from previousDatabaseEncryptionKey: Swift.String)
  @objc deinit
}
@objc(APCModuleTag) public enum ModuleTag : Swift.UInt {
  case actionBased = 0
  case analytics = 1
  case apm = 2
  case appInbox = 3
  case backoff = 4
  case core = 5
  case db = 6
  case deeplink = 7
  case eventLimit = 8
  case event = 9
  case goal = 10
  case inApp = 11
  case remoteConfig = 12
  case screenTracking = 13
  case superAttribute = 14
  case geolocation = 15
  case snapshot = 16
  case geofence = 17
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
extension AppConnect.ModuleTag : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(APCNetworkConnectionType) @objcMembers public class ConnectionType : ObjectiveC.NSObject, Swift.OptionSet {
  @objc public static let none: AppConnect.ConnectionType
  @objc public static let cellular: AppConnect.ConnectionType
  @objc public static let wifi: AppConnect.ConnectionType
  @objc public static let ethernet: AppConnect.ConnectionType
  @objc public static let bluetooth: AppConnect.ConnectionType
  @objc public static let wifiAware: AppConnect.ConnectionType
  @objc public static let loWpan: AppConnect.ConnectionType
  @objc public static let vpn: AppConnect.ConnectionType
  public typealias RawValue = Swift.Int
  @objc public var rawValue: Swift.Int
  @objc required override convenience dynamic public init()
  @objc required public init(rawValue: Swift.Int)
  @objc override dynamic public var hash: Swift.Int {
    @objc get
  }
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc public func formUnion(_ other: AppConnect.ConnectionType)
  @objc public func formIntersection(_ other: AppConnect.ConnectionType)
  @objc public func formSymmetricDifference(_ other: AppConnect.ConnectionType)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  public typealias ArrayLiteralElement = AppConnect.ConnectionType
  public typealias Element = AppConnect.ConnectionType
  @objc deinit
}
@available(iOS 13.0, *)
extension SwiftUI.View {
  public func appConnectTracker(domain: Swift.String? = nil, name: Swift.String) -> some SwiftUI.View
  
  public func startTracking(domain: Swift.String? = nil, name: Swift.String, extras: AppConnect.ViewTrackingExtras? = nil)
  public func stopTracking(domain: Swift.String? = nil, name: Swift.String, extras: AppConnect.ViewTrackingExtras? = nil)
}
public struct ActionBasedMessage : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc(APCInAppMessageContent) @objcMembers final public class InAppMessageContent : ObjectiveC.NSObject, Swift.Codable {
  @objc final public var text: Swift.String? {
    get
  }
  @objc final public var title: Swift.String? {
    get
  }
  @objc final public var language: Swift.String? {
    get
  }
  @objc final public var buttons: [AppConnect.InAppMessageButton]? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
public typealias ResultCompletion<T> = (AppConnect.Result<T>) -> Swift.Void
extension Foundation.NSNotification.Name {
  public static let pushEventManagerDidReceivePushEvent: Foundation.Notification.Name
  public static let eventManagerTriggeredEvent: Foundation.Notification.Name
  public static let eventCollectingStateWillChange: Foundation.Notification.Name
  public static let eventCollectingStateDidChanged: Foundation.Notification.Name
  public static let apmManagerTriggeredEvent: Foundation.Notification.Name
  public static let languageCodeDidUpdate: Foundation.Notification.Name
}
public enum NotificationInfoKey {
  public enum PushEventManager {
  }
}
extension AppConnect.AppConnectConfig {
  @_hasMissingDesignatedInitializers @objc(APCNetworkConfig) @objcMembers final public class NetworkConfig : ObjectiveC.NSObject {
    @objc final public var trustPolicies: [AppConnect.AppConnectTrustPolicy]? {
      @objc get
      @objc set
    }
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers @objc(APCCertificate) @objcMembers public class Certificate : ObjectiveC.NSObject {
  @objc public static func file(_ file: AppConnect.CertificateFile) -> AppConnect.Certificate
  @objc public static func base64(_ encodedString: Swift.String) -> AppConnect.Certificate
  @objc deinit
}
@objc(APCCertificateFile) @objcMembers public class CertificateFile : ObjectiveC.NSObject {
  @objc public init(bundle: Foundation.Bundle, fileName: Swift.String, fileExtension: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(APCPushEvent) @objcMembers final public class PushEvent : ObjectiveC.NSObject, Swift.Codable {
  public enum CodingKeys {
    public enum APNS : Swift.String, Swift.CodingKey {
      case aps
      case pushID
      case eventID
      case scheduleID
      case mediaURL
      case targetURL
      case actionType
      case attributes
      case source
      case storeInbox
      case inboxExpiration
      case customerId
      case conversionRules
      case sdkKey
      public init?(rawValue: Swift.String)
      public init?(stringValue: Swift.String)
      public init?(intValue: Swift.Int)
      public typealias RawValue = Swift.String
      public var intValue: Swift.Int? {
        get
      }
      public var rawValue: Swift.String {
        get
      }
      public var stringValue: Swift.String {
        get
      }
    }
  }
  public enum Alert {
    case plain(Swift.String)
    case rich(title: Swift.String, body: Swift.String)
  }
  @objc final public var notificationAction: AppConnect.NotificationActionType {
    @objc get
  }
  final public let alert: AppConnect.PushEvent.Alert?
  @objc final public let soundName: Swift.String?
  final public let badge: Swift.Int?
  @objc final public let pushID: Swift.String?
  @objc final public let scheduleID: Swift.String?
  @objc final public let eventID: Swift.String?
  @objc final public let mediaURL: Foundation.URL?
  @objc final public let targetURL: Foundation.URL?
  final public let actionType: AppConnect.NotificationActionType?
  @objc final public let attributes: [Swift.String : Any]?
  @objc final public let conversionRules: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@objc extension UIKit.UITextField {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var apc_containsSensitiveObject: Swift.Bool {
    @objc get
    @objc set
  }
}
@objc extension UIKit.UITextView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var apc_containsSensitiveObject: Swift.Bool {
    @objc get
    @objc set
  }
}
@objc extension UIKit.UIButton {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var apc_containsSensitiveObject: Swift.Bool {
    @objc get
    @objc set
  }
}
@objc extension UIKit.UISwitch {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var apc_containsSensitiveObject: Swift.Bool {
    @objc get
    @objc set
  }
}
@objc extension UIKit.UIBarButtonItem {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var apc_containsSensitiveObject: Swift.Bool {
    @objc get
    @objc set
  }
}
@objc(APCInAppMessageButton) @objcMembers final public class InAppMessageButton : ObjectiveC.NSObject, Swift.Codable {
  final public var action: AppConnect.InAppMessageActionType? {
    get
  }
  @objc final public var actionURI: Swift.String? {
    get
  }
  @objc final public var buttonId: Swift.String? {
    get
  }
  @objc final public var text: Swift.String? {
    get
  }
  @objc final public var textToCopy: Swift.String? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class AppConnectAutoCollectingConfig : ObjectiveC.NSObject {
  @objc final public let domain: Swift.String?
  @objc final public let component: AppConnect.AutoCollectingComponentConfig
  @objc final public let gesture: AppConnect.AutoCollectingGestureConfig!
  @objc final public let apm: AppConnect.AutoCollectingAPMConfig!
  @objc deinit
}
@objc @objcMembers final public class AppConnectUser : ObjectiveC.NSObject {
  @objc final public let customerId: Swift.String
  @objc final public var email: Swift.String?
  @objc final public var phone: Swift.String?
  @objc final public var nationalId: Swift.String?
  @objc final public var firstName: Swift.String?
  @objc final public var lastName: Swift.String?
  @objc final public var gender: AppConnect.Gender
  @objc final public var dateOfBirth: Foundation.Date?
  @objc final public var attributes: AppConnect.UserAttributes?
  @objc public init(customerId: Swift.String)
  @objc deinit
}
@objc(APCTextFieldTrackingAttributes) @objcMembers final public class TextFieldTrackingAttributes : AppConnect.UIEventTrackingAttributes {
  @objc public init(textField: UIKit.UITextField)
  @objc public init(className: Swift.String, value: Swift.String, placeholder: Swift.String? = nil, accessibilityLabel: Swift.String? = nil, componentId: Swift.String? = nil, coordinates: AppConnect.UIViewPixelCoordinate? = nil, viewLabel: Swift.String? = nil, viewClass: Swift.String? = nil)
  override final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@objc(APCAPMHTTPRecord) @objcMembers final public class APMHTTPRecord : ObjectiveC.NSObject, Swift.Encodable {
  @objc final public var url: Swift.String {
    @objc get
    @objc set
  }
  final public var method: AppConnect.HTTPMethod?
  final public var statusCode: Swift.Int?
  final public var requestSize: Swift.Double?
  final public var responseSize: Swift.Double?
  final public var duration: Swift.Double?
  final public var success: Swift.Bool?
  @objc final public var errorType: Swift.String?
  @objc final public var errorCode: Swift.String?
  @objc final public var errorMessage: Swift.String?
  @objc final public var attributes: AppConnect.APMAttributes? {
    @objc get
    @objc set
  }
  public init(url: Swift.String, method: AppConnect.HTTPMethod? = nil, statusCode: Swift.Int? = nil, duration: Foundation.TimeInterval? = nil, success: Swift.Bool? = nil, domain: Swift.String? = nil)
  @objc convenience public init(url: Swift.String, domain: Swift.String? = nil)
  @objc convenience public init(url: Swift.String, method: AppConnect.HTTPMethod, statusCode: Swift.Int, duration: Foundation.TimeInterval, success: Swift.Bool, domain: Swift.String? = nil)
  final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@available(*, unavailable)
extension AppConnect.APMHTTPRecord {
  @objc final public func getMethod() -> AppConnect.HTTPMethod
  @objc final public func setMethod(_ method: AppConnect.HTTPMethod)
  @objc final public func getStatusCode() -> Swift.Int
  @objc final public func setStatusCode(_ statusCode: Swift.Int)
  @objc final public func getDuration() -> Foundation.TimeInterval
  @objc final public func setDuration(_ duration: Foundation.TimeInterval)
  @objc final public func getSuccess() -> Swift.Bool
  @objc final public func setSuccess(_ success: Swift.Bool)
}
final public class InAppMessageTrigger : Swift.Codable {
  final public var displayFrequency: AppConnect.InAppMessageDisplayFrequency? {
    get
  }
  final public var delay: Swift.Double? {
    get
  }
  final public var eventName: Swift.String? {
    get
  }
  final public var attributeConditions: [AppConnect.InAppMessageAttributeCondition]? {
    get
  }
  final public var deviceConditions: [AppConnect.InAppMessageAttributeCondition]? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(APCPushEventManager) @objcMembers final public class PushEventManager : ObjectiveC.NSObject {
  @objc final public var latestPushEvent: AppConnect.PushEvent? {
    @objc get
  }
  final public var latest: (pushEvent: AppConnect.PushEvent, info: AppConnect.PushEventInfo)? {
    get
    set
  }
  @objc deinit
}
public protocol FileDownloaderProtocol {
  @discardableResult
  func downloadFile(at fileURL: Foundation.URL, completion: @escaping (AppConnect.Result<Foundation.URL>) -> Swift.Void) -> Foundation.URLSessionTask?
}
@objcMembers final public class FileDownloader : AppConnect.FileDownloaderProtocol {
  public enum Failure : Swift.Error {
    case unknown
    case downloadFailed(Swift.Error)
    case invalidDestination
    case fileMoveFailed(Swift.Error)
  }
  public static let shared: AppConnect.FileDownloader
  @objc final public let urlSession: Foundation.URLSession
  @objc final public let directory: Swift.String
  @objc final public let fileManager: Foundation.FileManager
  @objc public init(urlSession: Foundation.URLSession = URLSession.shared, directory: Swift.String = NSTemporaryDirectory(), fileManager: Foundation.FileManager = FileManager.default)
  @discardableResult
  final public func downloadFile(at fileURL: Foundation.URL, completion: @escaping (AppConnect.Result<Foundation.URL>) -> Swift.Void) -> Foundation.URLSessionTask?
  @objc deinit
}
public var appDefaultLanguage: Swift.String {
  get
}
@_hasMissingDesignatedInitializers @objc(APCPurchaseEventAttributes) @objcMembers final public class PurchaseEventAttributes : AppConnect.Attributes {
  @objc convenience public init(currency: Swift.String, value: Foundation.Decimal, products: [AppConnect.Product]?, success: Swift.Bool, domain: Swift.String? = nil)
  @objc @discardableResult
  final public func addTax(_ tax: Foundation.Decimal) -> AppConnect.PurchaseEventAttributes
  @objc @discardableResult
  final public func addShip(_ ship: Foundation.Decimal) -> AppConnect.PurchaseEventAttributes
  @objc @discardableResult
  final public func addDiscount(_ discount: Foundation.Decimal) -> AppConnect.PurchaseEventAttributes
  @objc @discardableResult
  final public func addCoupon(_ coupon: Swift.String) -> AppConnect.PurchaseEventAttributes
  @objc @discardableResult
  final public func addTrxId(_ trxId: Swift.String) -> AppConnect.PurchaseEventAttributes
  @objc @discardableResult
  final public func addPaymentMethod(_ paymentMethod: Swift.String) -> AppConnect.PurchaseEventAttributes
  @objc @discardableResult
  final public func addQuantity(_ quantity: Swift.Int) -> AppConnect.PurchaseEventAttributes
  @objc @discardableResult
  final public func addErrorCode(_ errorCode: Swift.String) -> AppConnect.PurchaseEventAttributes
  @objc @discardableResult
  final public func addErrorMessage(_ errorMessage: Swift.String) -> AppConnect.PurchaseEventAttributes
  @objc deinit
}
@objc(APCInAppMessageCustomContent) @objcMembers final public class InAppMessageCustomContent : ObjectiveC.NSObject, Swift.Codable {
  @objc final public var url: Foundation.URL {
    get
  }
  @objc final public var language: Swift.String {
    get
  }
  @objc final public var location: AppConnect.InAppMessageLocation {
    get
  }
  final public var horizontalLocation: AppConnect.InAppMessageHorizontalLocation? {
    get
  }
  final public var displayDuration: Swift.Int? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@objc(APCInAppMessageHorizontalLocation) public enum InAppMessageHorizontalLocation : Swift.Int, Swift.CustomStringConvertible, Swift.Decodable {
  case right
  case center
  case left
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum GeofencePushEventSource : Swift.String {
  case onEnter
  case onExit
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers final public class AppConnectClient : ObjectiveC.NSObject {
  @objc weak final public var eventListenerDelegate: AppConnect.AppConnectEventListenerDelegate? {
    @objc get
    @objc set
  }
  @objc weak final public var inAppMessageListenerDelegate: AppConnect.InAppMessageListener? {
    @objc get
    @objc set
  }
  @objc weak final public var alertTapListenerDelegate: AppConnect.InAppMessageAlertTapListener? {
    @objc get
    @objc set
  }
  @objc weak final public var alertDeeplinkHandlerDelegate: AppConnect.InAppMessageAlertDeeplinkHandler? {
    @objc get
    @objc set
  }
  @objc weak final public var autoCollectingApmListenerDelegate: AppConnect.AutoCollectingApmListener? {
    @objc get
    @objc set
  }
  @objc final public var screenTracker: AppConnect.ScreenTracker {
    @objc get
  }
  @objc final public let listener: AppConnect.AppListener
  @objc final public let pushEventManager: AppConnect.PushEventManager!
  @objc final public let config: AppConnect.AppConnectConfig
  @objc final public var inbox: AppConnect.AppInbox? {
    @objc get
  }
  @objc deinit
}
extension AppConnect.AppConnectClient {
  @objc public static func initialize(config: AppConnect.AppConnectConfig) -> AppConnect.AppConnectClient?
}
extension AppConnect.AppConnectClient {
  @objc final public func enableGeofencing()
  @objc final public func disableGeofencing()
}
extension AppConnect.AppConnectClient {
  @objc final public func setUser(_ user: AppConnect.AppConnectUser)
  @objc final public func updateUser(attributes: AppConnect.UserAttributes)
  @objc final public func clearUser()
  @objc final public var deviceId: Swift.String {
    @objc get
  }
  @objc final public func devicePropertyString() -> Swift.String?
  @objc final public func collectAPMHTTPRecord(_ record: AppConnect.APMHTTPRecord)
  @objc final public func collectAPMNetworkRecord(_ record: AppConnect.APMNetworkRecord)
}
extension AppConnect.AppConnectClient {
  @objc final public func updateLanguage(languageCode: Swift.String)
}
extension AppConnect.AppConnectClient {
  @objc final public func setSuperAttribute(key: Swift.String, value: Swift.String)
  @objc final public func setSuperAttribute(key: Swift.String, intValue: Swift.Int)
  @objc final public func setSuperAttribute(key: Swift.String, doubleValue: Swift.Double)
  @objc final public func setSuperAttribute(key: Swift.String, int64Value: Swift.Int64)
  @objc final public func setSuperAttribute(key: Swift.String, floatValue: Swift.Float)
  @objc final public func setSuperAttribute(key: Swift.String, boolValue: Swift.Bool)
  @objc final public func setSuperAttribute(key: Swift.String, dateValue: Foundation.Date)
  @objc final public func clearSuperAttribute(key: Swift.String) -> Swift.Bool
}
extension AppConnect.AppConnectClient {
  @objc final public func setCountry(_ country: Swift.String)
  @objc final public func setContinent(_ continent: Swift.String)
  @objc final public func setCity(_ city: Swift.String)
  @objc final public func setRegion(_ region: Swift.String)
  @objc final public func updateCoordinates(latitude: Swift.Double, longitude: Swift.Double)
  @objc final public func clearCountry()
  @objc final public func clearContinent()
  @objc final public func clearCity()
  @objc final public func clearRegion()
  @objc final public func clearCoordinates()
}
@objc(APCInAppMessageDisplayFrequency) public enum InAppMessageDisplayFrequency : Swift.Int, Swift.Codable {
  case oncePerEvent
  case oncePerSession
  case everyTime
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension AppConnect.InAppMessageDisplayFrequency : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class UserNotificationIntegrator : ObjectiveC.NSObject {
  @objc final public var languageCode: Swift.String {
    @objc get
  }
  @objc final public var inbox: AppConnect.AppInbox? {
    @objc get
  }
  public static func initialize(config: AppConnect.AppConnectConfig, downloader: AppConnect.FileDownloader) -> AppConnect.UserNotificationIntegrator?
  @objc public static func initialize(config: AppConnect.AppConnectConfig) -> AppConnect.UserNotificationIntegrator?
  @objc(processWithContent:completion:) final public func process(content: UserNotifications.UNMutableNotificationContent, _ completion: @escaping (UserNotifications.UNMutableNotificationContent) -> Swift.Void)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class AppConnectAppInboxConfig : ObjectiveC.NSObject {
  @objc final public var isEnabled: Swift.Bool
  @objc final public var storageLimit: Swift.Int
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(APCLongPressTrackingAttributes) @objcMembers final public class LongPressTrackingAttributes : AppConnect.TapTrackingAttributes {
  @objc override public init(touchPoint: AppConnect.TouchPoint, viewLabel: Swift.String? = nil, viewClass: Swift.String? = nil)
  @objc deinit
}
@objc(APCInAppMessageListener) public protocol InAppMessageListener {
  @objc optional func didReceiveInAppMessage(content: AppConnect.InAppMessageContent)
  @objc optional func didReceiveCustomInAppMessage(content: AppConnect.InAppMessageCustomContent)
}
@objc(APCInAppMessageAlertTapListener) public protocol InAppMessageAlertTapListener {
  @objc optional func didTapAlert(button: AppConnect.InAppMessageButton, content: AppConnect.InAppMessageContent)
  @objc optional func didTapCustomButton(button: AppConnect.InAppMessageButton, content: AppConnect.InAppMessageCustomContent)
}
@objc(APCInAppMessageAlertDeeplinkHandler) public protocol InAppMessageAlertDeeplinkHandler {
  @objc func shouldHandleDeeplink(deeplink: Swift.String?)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers final public class AppConnectConfig : ObjectiveC.NSObject {
  @objc final public let sdkKey: Swift.String
  @objc final public let serverURL: Swift.String
  @objc final public let domain: Swift.String?
  @objc final public var multipleInstanceMigrationEnabled: Swift.Bool
  @objc final public var eventCollectingDisabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var eventStorageLimit: Swift.Int
  @objc final public var sessionDropDuration: Swift.Double
  @objc final public var resetDatabase: Swift.Bool
  @objc final public let push: AppConnect.AppConnectConfig.PushConfig
  @objc final public let screenTracking: AppConnect.AppConnectConfig.ScreenTrackingConfig
  @objc final public let apm: AppConnect.AppConnectConfig.APMConfig
  @objc final public let inApp: AppConnect.AppConnectConfig.InAppMessagingConfig
  @objc final public let logger: AppConnect.LoggerConfig
  @objc final public let network: AppConnect.AppConnectConfig.NetworkConfig
  @objc final public let snapshot: AppConnect.AppConnectConfig.SnapshotConfig
  @objc final public let appInbox: AppConnect.AppConnectConfig.AppInboxConfig!
  @objc final public var appGroupIdentifier: Swift.String? {
    @objc get
    @objc set
  }
  @objc final public let autoCollecting: AppConnect.AppConnectAutoCollectingConfig
  @objc final public var eventsToListen: [Swift.String]?
  @objc final public var frameworkIdentifier: Swift.String?
  @objc final public let databaseConfig: AppConnect.AppConnectConfig.DatabaseConfig
  @objc final public var languageCode: Swift.String {
    @objc get
  }
  @objc convenience public init(sdkKey: Swift.String, serverURL: Swift.String, languageCode: Swift.String = appDefaultLanguage, domain: Swift.String? = nil)
  @objc public init(sdkKey: Swift.String, serverURL: Swift.String, languageCode: Swift.String = appDefaultLanguage, databaseConfig: AppConnect.AppConnectConfig.DatabaseConfig? = nil, domain: Swift.String? = nil)
  @objc deinit
}
extension AppConnect.AppConnectConfig {
  public typealias ScreenTrackingConfig = AppConnect.AppConnectScreenTrackingConfig
  public typealias APMConfig = AppConnect.AppConnectAPMConfig
  public typealias PushConfig = AppConnect.AppConnectPushConfig
  public typealias InAppMessagingConfig = AppConnect.AppConnectInAppMessagingConfig
  public typealias SnapshotConfig = AppConnect.AppConnectSnapshotConfig
  public typealias AppInboxConfig = AppConnect.AppConnectAppInboxConfig
  public typealias AutoCollect = AppConnect.AppConnectAutoCollectingConfig
  public typealias DatabaseConfig = AppConnect.AppConnectDatabaseConfig
}
extension AppConnect.AppConnectConfig {
  @objc final public func pauseEventCollection()
  @objc final public func resumeEventCollection()
}
@_hasMissingDesignatedInitializers @objc(APCAppListener) final public class AppListener : ObjectiveC.NSObject {
  @objc final public func appDidFinishLaunching(withOptions launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]?)
  @objc final public func appDidRegisterForRemoteNotifications(withDeviceToken tokenData: Foundation.Data)
  @objc final public func appDidReceiveRemoteNotification(_ userInfo: [Swift.AnyHashable : Any], handleAction: Swift.Bool = false)
  @objc final public func appWillPresentNotification(_ notification: UserNotifications.UNNotification)
  @objc deinit
}
@objc(APCScreenTracker) public protocol ScreenTracker {
  @objc func startAutoTracking()
  @objc func stopAutoTracking()
  @objc func startTracking(view: ObjectiveC.NSObjectProtocol, name: Swift.String)
  @objc func startTracking(view: ObjectiveC.NSObjectProtocol, name: Swift.String, extras: AppConnect.ViewTrackingExtras?)
  @objc func startTracking(viewClass: Swift.String, name: Swift.String)
  @objc func startTracking(viewClass: Swift.String, name: Swift.String, extras: AppConnect.ViewTrackingExtras?)
  @objc func stopTracking(view: ObjectiveC.NSObjectProtocol, name: Swift.String)
  @objc func stopTracking(view: ObjectiveC.NSObjectProtocol, name: Swift.String, extras: AppConnect.ViewTrackingExtras?)
  @objc func stopTracking(viewClass: Swift.String, name: Swift.String)
  @objc func stopTracking(viewClass: Swift.String, name: Swift.String, extras: AppConnect.ViewTrackingExtras?)
}
@objc(APCTrustPolicy) @objcMembers final public class AppConnectTrustPolicy : ObjectiveC.NSObject {
  @objc convenience public init(evaluationDisabledPolicyWithEndpoint endpoint: Swift.String, certificates: [AppConnect.Certificate])
  @objc public init(endpoint: Swift.String, certificates: [AppConnect.Certificate], evaluationDisabled: Swift.Bool = false)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class AppConnectScreenTrackingConfig : ObjectiveC.NSObject {
  @objc final public var enabled: Swift.Bool
  @objc final public var autoTrackingEnabled: Swift.Bool
  @objc final public var shouldTrackInnerViewController: Swift.Bool
  @objc final public var viewControllerExclusions: Swift.Set<Swift.String>
  @objc override dynamic public init()
  @objc deinit
}
public enum PushEventInfo {
  case receivedWhenTerminatedAndOpenedTheApp
  case receivedInBackgroundAndOpenedTheApp
  case receivedInBackground
  case receivedInForeground
  public static func == (a: AppConnect.PushEventInfo, b: AppConnect.PushEventInfo) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AppConnect.PushEventInfo : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @objc(APCDoubleTapTrackingAttributes) @objcMembers final public class DoubleTapTrackingAttributes : AppConnect.TapTrackingAttributes {
  @objc override public init(touchPoint: AppConnect.TouchPoint, viewLabel: Swift.String? = nil, viewClass: Swift.String? = nil)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(APCAttributes) @objcMembers public class Attributes : ObjectiveC.NSObject {
  @objc convenience public init(name: Swift.String, domain: Swift.String? = nil)
  @objc override dynamic public init()
  @objc deinit
}
extension AppConnect.Attributes {
  @objc @discardableResult
  dynamic public func addInt(_ value: Swift.Int, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addDouble(_ value: Swift.Double, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addFloat(_ value: Swift.Float, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addBool(_ value: Swift.Bool, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addString(_ value: Swift.String, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addDate(_ value: Foundation.Date, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addDecimal(_ value: Foundation.Decimal, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addNumber(_ value: Foundation.NSNumber, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addStringArray(_ value: [Swift.String], forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addIntArray(_ value: [Swift.Int], forKey name: Swift.String) -> Self
  @objc dynamic public func collect()
}
@objc(APCGender) public enum Gender : Swift.Int, Swift.CustomStringConvertible, Swift.Codable {
  case undefined
  case male
  case female
  case nonBinary
  case unknown
  public var description: Swift.String {
    get
  }
  public static func instanceFromString(_ string: Swift.String) -> AppConnect.Gender?
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc(APCInAppMessageAttributeCondition) @objcMembers public class InAppMessageAttributeCondition : ObjectiveC.NSObject, Swift.Codable {
  @objc public var key: Swift.String {
    get
  }
  public var operation: AppConnect.InAppMessageAttributeConditionOperation {
    get
  }
  @objc public var values: [Swift.String] {
    get
  }
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
precedencegroup ColumnAssignment {
  associativity: left
  assignment: true
  lowerThan: AssignmentPrecedence
}
infix operator <- : ColumnAssignment
@objc(APCAutoCollectionApmListener) public protocol AutoCollectingApmListener {
  @objc optional func willCollectHttpRecord(record: AppConnect.APMHTTPRecord) -> AppConnect.APMMutableHttpRecord
  @objc optional func willCollectNetworkRecord(record: AppConnect.APMNetworkRecord) -> AppConnect.APMMutableNetworkRecord
}
@objc(APCNotificationActionType) public enum NotificationActionType : Swift.Int, Swift.CustomStringConvertible {
  case none
  case openApp
  case gotoUrl
  case gotoDeeplink
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc(APCLoggerLevel) public enum LoggerLevel : Swift.UInt {
  case none = 0
  case error = 1
  case warning = 2
  case info = 3
  case debug = 4
  case verbose = 5
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
extension AppConnect.LoggerLevel : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @objc(APCStartCheckoutEventAttributes) @objcMembers final public class StartCheckoutEventAttributes : AppConnect.Attributes {
  @objc convenience public init(value: Foundation.Decimal, currency: Swift.String, domain: Swift.String? = nil)
  @objc @discardableResult
  final public func addQuantity(_ quantity: Swift.Int) -> AppConnect.StartCheckoutEventAttributes
  @objc deinit
}
@objc(APCDeeplinkAttributes) @objcMembers final public class DeeplinkAttributes : ObjectiveC.NSObject {
  @objc public init(url: Foundation.URL, domain: Swift.String? = nil)
  @objc public init(url: Foundation.URL, options: [UIKit.UIApplication.OpenURLOptionsKey : Any], domain: Swift.String? = nil)
  @objc final public func collect()
  @objc deinit
}
extension AppConnect.DeeplinkAttributes {
  @objc @discardableResult
  final public func addInt(_ value: Swift.Int, forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addDouble(_ value: Swift.Double, forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addFloat(_ value: Swift.Float, forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addBool(_ value: Swift.Bool, forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addString(_ value: Swift.String, forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addDate(_ value: Foundation.Date, forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addDecimal(_ value: Foundation.Decimal, forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addStringArray(_ value: [Swift.String], forKey name: Swift.String) -> Self
  @objc @discardableResult
  final public func addIntArray(_ value: [Swift.Int], forKey name: Swift.String) -> Self
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class AppConnectSnapshotConfig : ObjectiveC.NSObject {
  @objc final public var recordingEnabled: Swift.Bool
  @objc final public var latencyInMillis: Swift.Int
  @objc final public var enabledBundleIDs: [Swift.String]? {
    @objc get
    @objc set
  }
  @objc override dynamic public init()
  @objc deinit
}
@objc(APCAPMNetworkRecord) @objcMembers final public class APMNetworkRecord : ObjectiveC.NSObject, Swift.Encodable {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(APCAPMNetworkRecordErrorType) @objcMembers public class ErrorType : ObjectiveC.NSObject, Swift.OptionSet {
    @objc public static let unknown: AppConnect.APMNetworkRecord.ErrorType
    @objc public static let noConnection: AppConnect.APMNetworkRecord.ErrorType
    @objc public static let ssl: AppConnect.APMNetworkRecord.ErrorType
    @objc public static let timeout: AppConnect.APMNetworkRecord.ErrorType
    @objc public static let insecureConnection: AppConnect.APMNetworkRecord.ErrorType
    @objc public var rawValue: Swift.Int
    public typealias RawValue = Swift.Int
    @objc required override convenience dynamic public init()
    @objc required public init(rawValue: Swift.Int)
    @objc override dynamic public var hash: Swift.Int {
      @objc get
    }
    @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
    @objc public func formUnion(_ other: AppConnect.APMNetworkRecord.ErrorType)
    @objc public func formIntersection(_ other: AppConnect.APMNetworkRecord.ErrorType)
    @objc public func formSymmetricDifference(_ other: AppConnect.APMNetworkRecord.ErrorType)
    @objc public init?(error: Foundation.NSError)
    @objc override dynamic public var description: Swift.String {
      @objc get
    }
    public typealias ArrayLiteralElement = AppConnect.APMNetworkRecord.ErrorType
    public typealias Element = AppConnect.APMNetworkRecord.ErrorType
    @objc deinit
  }
  @objc final public var url: Swift.String {
    @objc get
    @objc set
  }
  final public var method: AppConnect.HTTPMethod?
  @objc final public var headers: [Swift.String : Swift.String]?
  final public var duration: Foundation.TimeInterval?
  @objc final public var type: AppConnect.APMNetworkRecord.ErrorType?
  @objc final public var exception: Swift.String?
  @objc final public var message: Swift.String?
  @objc final public var attributes: AppConnect.APMAttributes? {
    @objc get
    @objc set
  }
  public init(url: Swift.String, method: AppConnect.HTTPMethod? = nil, duration: Foundation.TimeInterval? = nil, type: AppConnect.APMNetworkRecord.ErrorType? = nil, exception: Swift.String? = nil, domain: Swift.String? = nil)
  @objc convenience public init(url: Swift.String, domain: Swift.String? = nil)
  @objc convenience public init(url: Swift.String, method: AppConnect.HTTPMethod, duration: Foundation.TimeInterval, type: AppConnect.APMNetworkRecord.ErrorType, exception: Swift.String, domain: Swift.String? = nil)
  final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@available(*, unavailable)
extension AppConnect.APMNetworkRecord {
  @objc final public func getMethod() -> AppConnect.HTTPMethod
  @objc final public func setMethod(_ method: AppConnect.HTTPMethod)
  @objc final public func getDuration() -> Foundation.TimeInterval
  @objc final public func setDuration(_ duration: Foundation.TimeInterval)
}
@objc @_hasMissingDesignatedInitializers public class SearchEventBuilder : ObjectiveC.NSObject {
  @objc deinit
}
final public class InAppMessage : Swift.Codable {
  final public var messageID: Swift.String? {
    get
  }
  final public var triggers: [AppConnect.InAppMessageTrigger]? {
    get
  }
  final public var defaultLanguage: Swift.String? {
    get
  }
  final public var contents: [AppConnect.InAppMessageContent]? {
    get
  }
  final public var customContents: [AppConnect.InAppMessageCustomContent]? {
    get
  }
  final public var isHandledOutsideSDK: Swift.Bool {
    get
  }
  final public var schedule: AppConnect.InAppMessageSchedule? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(APCAddToWishListEventAttributes) @objcMembers final public class AddToWishListEventAttributes : AppConnect.Attributes {
  @objc convenience public init(product: AppConnect.Product, domain: Swift.String? = nil)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class APCURLSessionCollector : ObjectiveC.NSObject {
  @objc public static let shared: AppConnect.APCURLSessionCollector
  @objc final public func startTracking(task: Foundation.URLSessionTask)
  @objc final public func endTracking(task: Foundation.URLSessionTask?, data: Foundation.Data?)
  @objc final public func endTracking(url: Foundation.URL, data: Foundation.Data?)
  @objc override dynamic public init()
  @objc deinit
}
@objcMembers @objc(APCProduct) final public class Product : ObjectiveC.NSObject, Swift.Encodable {
  @objc final public var id: Swift.String
  @objc final public var name: Swift.String
  @objc final public var productDescription: Swift.String?
  @objc final public var brand: Swift.String?
  @objc final public var quantity: Swift.Int
  @objc final public var price: Foundation.Decimal
  @objc final public var variant: Swift.String?
  @objc final public var category: Swift.String?
  @objc final public var currency: Swift.String
  @objc public init?(id: Swift.String, name: Swift.String, quantity: Swift.Int, price: Foundation.Decimal, currency: Swift.String)
  final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
extension Foundation.UUID {
  public static func timeBasedUUID() -> Foundation.UUID
}
@_hasMissingDesignatedInitializers @objc(APCRemoveFromWishListEventAttributes) @objcMembers final public class RemoveFromWishListEventAttributes : AppConnect.Attributes {
  @objc convenience public init(product: AppConnect.Product, domain: Swift.String? = nil)
  @objc deinit
}
@objc(APCCustomEventBuilder) @objcMembers final public class CustomEventBuilder : ObjectiveC.NSObject {
  @objc public init(domain: Swift.String? = nil, eventName: Swift.String)
  @objc @discardableResult
  final public func addAttributes(_ attributes: [Swift.String : Any]) -> AppConnect.CustomEventBuilder
  @objc @discardableResult
  final public func addDate(_ date: Foundation.Date, key: Swift.String) -> AppConnect.CustomEventBuilder
  @objc @discardableResult
  final public func addBoolean(_ boolean: Swift.Bool, key: Swift.String) -> AppConnect.CustomEventBuilder
  @objc @discardableResult
  final public func addNumber(_ number: Foundation.NSNumber, key: Swift.String) -> AppConnect.CustomEventBuilder
  @objc @discardableResult
  final public func addString(_ string: Swift.String, key: Swift.String) -> AppConnect.CustomEventBuilder
  @objc deinit
}
@objc(APCUIEventTrackingAttributes) @objcMembers public class UIEventTrackingAttributes : ObjectiveC.NSObject, Swift.Encodable {
  @objc public init(viewLabel: Swift.String? = nil, viewClass: Swift.String? = nil)
  public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
extension AppConnect.UIEventTrackingAttributes {
  @objc dynamic public func collect(domain: Swift.String? = nil)
}
@_inheritsConvenienceInitializers @objcMembers @objc(APCAppInboxQuery) final public class AppInboxQuery : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc final public func messageType(_ messageType: AppConnect.InboxMessageType) -> AppConnect.AppInboxQuery
  @objc final public func status(_ status: AppConnect.InboxMessageStatus) -> AppConnect.AppInboxQuery
  @objc final public func from(_ from: Foundation.Date) -> AppConnect.AppInboxQuery
  @objc final public func to(_ to: Foundation.Date) -> AppConnect.AppInboxQuery
  @objc final public func anonymous(_ anonymous: Swift.Bool) -> AppConnect.AppInboxQuery
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(APCAPMMutableNetworkRecord) @objcMembers final public class APMMutableNetworkRecord : ObjectiveC.NSObject {
  @objc final public var message: Swift.String?
  @objc final public var attributes: AppConnect.APMAttributes?
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class AppConnectPushConfig : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@objc(ACHTTPMethod) public enum HTTPMethod : Swift.Int, Swift.Codable, Swift.CustomStringConvertible {
  case GET = 0
  case HEAD = 1
  case POST = 2
  case PUT = 3
  case DELETE = 4
  case CONNECT = 5
  case OPTIONS = 6
  case TRACE = 7
  case PATCH = 8
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol SnapshotCollector : AnyObject {
  var pathURL: Foundation.URL? { get set }
  func takeSnapshot(viewId: Swift.String, completion: @escaping (Swift.Error?, Foundation.URL?) -> Swift.Void)
  func setLoggerDelegate(_ delegate: AppConnect.SnapshotLogger)
}
extension AppConnect.SnapshotCollector {
  public func setLoggerDelegate(_ delegate: AppConnect.SnapshotLogger)
}
@_hasMissingDesignatedInitializers @objc(APCViewProductEventAttributes) @objcMembers final public class ViewProductEventAttributes : AppConnect.Attributes {
  @objc convenience public init(product: AppConnect.Product, domain: Swift.String? = nil)
  @objc deinit
}
extension UserNotifications.UNNotificationContent {
  @objc dynamic public var isFromConnect: Swift.Bool {
    @objc get
  }
  @objc dynamic public func isMatches(with sdkKey: Swift.String) -> Swift.Bool
}
@objc(APCAppInboxDelegate) public protocol AppInboxDelegate {
  @objc func inbox(_ inbox: AppConnect.AppInbox, didUpdate message: AppConnect.InboxMessage)
  @objc func inbox(_ inbox: AppConnect.AppInbox, didDeleteMessages ids: [Swift.Int64])
}
@_hasMissingDesignatedInitializers @objcMembers @objc(APCAppInbox) final public class AppInbox : ObjectiveC.NSObject {
  @objc weak final public var delegate: AppConnect.AppInboxDelegate?
  @objc final public func fetchMessages() -> [AppConnect.InboxMessage]?
  @objc final public func fetchMessages(query: AppConnect.AppInboxQuery?) -> [AppConnect.InboxMessage]?
  @objc final public func deleteMessages(ids: [Swift.Int64]) -> Swift.Bool
  @objc final public func readMessages(ids: [Swift.Int64]) -> Swift.Bool
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class AutoCollectingAPMConfig : ObjectiveC.NSObject {
  @objc final public var isEnabled: Swift.Bool
  @objc deinit
}
extension AppConnect.AutoCollectingAPMConfig {
  @objc public static var apmEnabled: Swift.Bool {
    @objc get
  }
  @objc public static var apmSwizzlingEnabled: Swift.Bool {
    @objc get
  }
}
public enum InAppMessageAttributeConditionOperation : Swift.String, Swift.Codable {
  case equal
  case notEqual
  case greater
  case greaterThanOrEqual
  case smallerThan
  case smallerThanOrEqual
  case contains
  case notContains
  case exactMatch
  case notExactMatch
  case containsAll
  case containsAny
  case notContainsAll
  case notContainsAny
  case booleanCase
  case before
  case after
  case between
  case exist
  case none
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol SnapshotLogger : AnyObject {
  func appConnectLog(_ level: AppConnect.LoggerLevel, file: Swift.String, line: Swift.Int, _ message: Swift.String)
}
@objc(APCTapTrackingAttributes) @objcMembers public class TapTrackingAttributes : AppConnect.UIEventTrackingAttributes {
  @objc public init(touchPoint: AppConnect.TouchPoint, viewLabel: Swift.String? = nil, viewClass: Swift.String? = nil)
  override public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@objc extension UIKit.UIButton {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var apc_isDebounceThresholdExclusion: Swift.Bool {
    @objc get
    @objc set
  }
}
@objc extension UIKit.UIBarButtonItem {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var apc_isDebounceThresholdExclusion: Swift.Bool {
    @objc get
    @objc set
  }
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class AppConnectInAppMessagingConfig : ObjectiveC.NSObject {
  @objc final public var inAppMessagingEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class AutoCollectingGestureConfig : ObjectiveC.NSObject {
  @objc final public var isEnabled: Swift.Bool
  @objc deinit
}
public enum Result<Value> {
  case success(Value)
  case failure(Swift.Error)
}
extension AppConnect.Result {
  public var isSuccess: Swift.Bool {
    get
  }
  public var value: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
  public func map<T>(_ transform: (Value) -> T) -> AppConnect.Result<T>
  public func flatMap<T>(_ transform: (Value) -> AppConnect.Result<T>) -> AppConnect.Result<T>
}
extension AppConnect.Result : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @objc(APCAPMAttributes) @objcMembers public class APMAttributes : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public init(domain: Swift.String? = nil)
  @objc deinit
}
extension AppConnect.APMAttributes {
  @objc @discardableResult
  dynamic public func addInt(_ value: Swift.Int, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addDouble(_ value: Swift.Double, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addFloat(_ value: Swift.Float, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addBool(_ value: Swift.Bool, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addString(_ value: Swift.String, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addDate(_ value: Foundation.Date, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addDecimal(_ value: Foundation.Decimal, forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addStringArray(_ value: [Swift.String], forKey name: Swift.String) -> Self
  @objc @discardableResult
  dynamic public func addIntArray(_ value: [Swift.Int], forKey name: Swift.String) -> Self
}
@_hasMissingDesignatedInitializers @objc(APCSearchEventAttributes) @objcMembers final public class SearchEventAttributes : AppConnect.Attributes {
  @objc convenience public init(query: Swift.String, domain: Swift.String? = nil)
  @objc deinit
}
@objc(APCInAppMessageActionType) public enum InAppMessageActionType : Swift.Int, Swift.CustomStringConvertible {
  case dismiss
  case gotoUrl
  case gotoDeeplink
  case copy
  case custom
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc(APCUIViewPixelCoordinate) @objcMembers public class UIViewPixelCoordinate : ObjectiveC.NSObject, Swift.Encodable {
  @objc public init(frame: CoreFoundation.CGRect)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
extension AppConnect.UIViewPixelCoordinate {
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
}
@objc(APCSwipeTrackingAttributes) @objcMembers public class SwipeTrackingAttributes : AppConnect.UIEventTrackingAttributes {
  @objc public init(startPoint: CoreFoundation.CGPoint, endPoint: CoreFoundation.CGPoint, viewLabel: Swift.String? = nil, viewClass: Swift.String? = nil)
  override public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers open class FTSConfig {
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class FTS4Config : AppConnect.FTSConfig {
  @objc deinit
}
@objc(APCButtonTrackingAttributes) @objcMembers final public class ButtonTrackingAttributes : AppConnect.UIEventTrackingAttributes {
  @objc public init(button: UIKit.UIButton)
  @objc public init(className: Swift.String, label: Swift.String? = nil, accessibilityLabel: Swift.String? = nil, componentId: Swift.String? = nil, coordinates: AppConnect.UIViewPixelCoordinate? = nil, viewLabel: Swift.String? = nil, viewClass: Swift.String? = nil)
  override final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@objc(APCTouchPoint) @objcMembers public class TouchPoint : ObjectiveC.NSObject, Swift.Encodable {
  @objc public init(point: CoreFoundation.CGPoint)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers @objc(APCClearCartEventAttributes) @objcMembers final public class ClearCartEventAttributes : AppConnect.Attributes {
  @objc convenience public init(domain: Swift.String? = nil)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(APCViewCategoryEventAttributes) @objcMembers final public class ViewCategoryEventAttributes : AppConnect.Attributes {
  @objc convenience public init(category: Swift.String, domain: Swift.String? = nil)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(DBInboxMessage) public class DBInboxMessage : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension AppConnect.DBInboxMessage {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<AppConnect.DBInboxMessage>
  @objc @NSManaged dynamic public var customerId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var expirationDate: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var id: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var payload: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var pushId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var receivedDate: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var scheduleId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var status: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var type: Swift.Int16 {
    @objc get
    @objc set
  }
}
@_inheritsConvenienceInitializers @objc(DBAPMRecord) public class DBAPMRecord : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension AppConnect.DBAPMRecord {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<AppConnect.DBAPMRecord>
  @objc @NSManaged dynamic public var id: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var payload: Swift.String? {
    @objc get
    @objc set
  }
}
@_inheritsConvenienceInitializers @objc(DBEvent) public class DBEvent : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension AppConnect.DBEvent {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<AppConnect.DBEvent>
  @objc @NSManaged dynamic public var id: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var payload: Swift.String? {
    @objc get
    @objc set
  }
}
@_inheritsConvenienceInitializers @objc(DBGeofence) public class DBGeofence : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension AppConnect.DBGeofence {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<AppConnect.DBGeofence>
  @objc @NSManaged dynamic public var id: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var payload: Swift.String? {
    @objc get
    @objc set
  }
}
@_inheritsConvenienceInitializers @objc(DBSession) public class DBSession : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension AppConnect.DBSession {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<AppConnect.DBSession>
  @objc @NSManaged dynamic public var id: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var payload: Swift.String? {
    @objc get
    @objc set
  }
}
@_inheritsConvenienceInitializers @objc(DBGoal) public class DBGoal : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension AppConnect.DBGoal {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<AppConnect.DBGoal>
  @objc @NSManaged dynamic public var eventName: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var expDate: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var id: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var payload: Swift.String? {
    @objc get
    @objc set
  }
}
@_inheritsConvenienceInitializers @objc(DBActionBased) public class DBActionBased : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension AppConnect.DBActionBased {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<AppConnect.DBActionBased>
  @objc @NSManaged dynamic public var date: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var delivered: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var id: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var parentId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var payload: Swift.String? {
    @objc get
    @objc set
  }
}
extension AppConnect.Platform : Swift.Equatable {}
extension AppConnect.Platform : Swift.Hashable {}
extension AppConnect.Platform : Swift.RawRepresentable {}
extension AppConnect.InboxMessageType : Swift.Equatable {}
extension AppConnect.InboxMessageType : Swift.Hashable {}
extension AppConnect.InboxMessageType : Swift.RawRepresentable {}
extension AppConnect.InboxMessageStatus : Swift.Equatable {}
extension AppConnect.InboxMessageStatus : Swift.Hashable {}
extension AppConnect.InboxMessageStatus : Swift.RawRepresentable {}
extension AppConnect.InAppMessageLocation : Swift.Equatable {}
extension AppConnect.InAppMessageLocation : Swift.Hashable {}
extension AppConnect.InAppMessageLocation : Swift.RawRepresentable {}
extension UIKit.UIWindow : UIKit.UIGestureRecognizerDelegate {}
extension AppConnect.ModuleTag : Swift.Equatable {}
extension AppConnect.ModuleTag : Swift.Hashable {}
extension AppConnect.ModuleTag : Swift.RawRepresentable {}
extension AppConnect.PushEvent.CodingKeys.APNS : Swift.Equatable {}
extension AppConnect.PushEvent.CodingKeys.APNS : Swift.Hashable {}
extension AppConnect.PushEvent.CodingKeys.APNS : Swift.RawRepresentable {}
extension AppConnect.InAppMessageHorizontalLocation : Swift.Equatable {}
extension AppConnect.InAppMessageHorizontalLocation : Swift.Hashable {}
extension AppConnect.InAppMessageHorizontalLocation : Swift.RawRepresentable {}
extension AppConnect.GeofencePushEventSource : Swift.Equatable {}
extension AppConnect.GeofencePushEventSource : Swift.Hashable {}
extension AppConnect.GeofencePushEventSource : Swift.RawRepresentable {}
extension AppConnect.InAppMessageDisplayFrequency : Swift.Equatable {}
extension AppConnect.InAppMessageDisplayFrequency : Swift.Hashable {}
extension AppConnect.InAppMessageDisplayFrequency : Swift.RawRepresentable {}
extension AppConnect.PushEventInfo : Swift.Equatable {}
extension AppConnect.PushEventInfo : Swift.Hashable {}
extension AppConnect.Gender : Swift.Equatable {}
extension AppConnect.Gender : Swift.Hashable {}
extension AppConnect.Gender : Swift.RawRepresentable {}
extension AppConnect.NotificationActionType : Swift.Equatable {}
extension AppConnect.NotificationActionType : Swift.Hashable {}
extension AppConnect.NotificationActionType : Swift.RawRepresentable {}
extension AppConnect.LoggerLevel : Swift.Equatable {}
extension AppConnect.LoggerLevel : Swift.Hashable {}
extension AppConnect.LoggerLevel : Swift.RawRepresentable {}
extension AppConnect.HTTPMethod : Swift.Equatable {}
extension AppConnect.HTTPMethod : Swift.Hashable {}
extension AppConnect.HTTPMethod : Swift.RawRepresentable {}
extension AppConnect.InAppMessageAttributeConditionOperation : Swift.Equatable {}
extension AppConnect.InAppMessageAttributeConditionOperation : Swift.Hashable {}
extension AppConnect.InAppMessageAttributeConditionOperation : Swift.RawRepresentable {}
extension AppConnect.InAppMessageActionType : Swift.Equatable {}
extension AppConnect.InAppMessageActionType : Swift.Hashable {}
extension AppConnect.InAppMessageActionType : Swift.RawRepresentable {}
